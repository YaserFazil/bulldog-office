"""
PDF to ngTeco CSV Converter Script
Extracts IN/OUT times and dates from PDF reports and converts them to ngTeco CSV format.

This script:
1. Parses PDF files generated by the platform
2. Extracts table data (Date, IN, OUT, Day, etc.)
3. Converts to ngTeco CSV format
"""

import pandas as pd
from datetime import datetime, date, timedelta
from typing import Dict, List, Optional, Tuple
import re
import pdfplumber
from io import BytesIO


def extract_table_from_pdf(pdf_content: bytes) -> Optional[pd.DataFrame]:
    """
    Extract the detailed work log table from PDF.
    Extracts from all pages and combines all matching tables.
    
    Args:
        pdf_content: PDF file content as bytes
    
    Returns:
        DataFrame with extracted table data from all pages, or None if extraction fails
    """
    try:
        pdf_file = BytesIO(pdf_content)
        all_data_rows = []
        header_row = None
        
        with pdfplumber.open(pdf_file) as pdf:
            for page_num, page in enumerate(pdf.pages):
                # Extract tables from each page
                page_tables = page.extract_tables()
                
                if not page_tables:
                    continue
                
                for table in page_tables:
                    if not table or len(table) < 2:
                        continue
                    
                    # Check if this table has the expected columns
                    current_header = table[0]
                    header_str = ' '.join([str(cell) if cell else '' for cell in current_header]).lower()
                    
                    if 'date' in header_str and 'in' in header_str and 'out' in header_str:
                        # Found a detailed work log table
                        # Store header if not already stored
                        if header_row is None:
                            header_row = current_header
                        
                        # Add data rows (skip header row)
                        for row in table[1:]:
                            # Skip if this looks like a header row (contains "Date", "IN", "OUT" as text)
                            row_str = ' '.join([str(cell) if cell else '' for cell in row]).lower()
                            if 'date' in row_str and ('in' in row_str or 'out' in row_str):
                                continue  # Skip header rows that appear in the middle
                            
                            # Only add rows that have at least some data
                            if row and any(cell and str(cell).strip() for cell in row):
                                all_data_rows.append(row)
        
        # If we found data, create DataFrame
        if header_row and all_data_rows:
            # Clean header row
            cleaned_header = [str(col).strip().replace('\n', ' ') if col else '' for col in header_row]
            
            # Create DataFrame
            df = pd.DataFrame(all_data_rows, columns=cleaned_header)
            
            # Clean up the DataFrame
            df = df.dropna(how='all')  # Remove completely empty rows
            
            # Find Date column for duplicate detection
            date_col = None
            for col in df.columns:
                if 'date' in str(col).lower():
                    date_col = col
                    break
            
            # Remove duplicate rows based on Date (if available), otherwise use all columns
            if date_col:
                # Remove duplicates based on Date column
                df = df.drop_duplicates(subset=[date_col], keep='first')
            else:
                # Fallback: remove duplicates based on all columns
                df = df.drop_duplicates()
            
            return df
        
        return None
    except Exception as e:
        print(f"Error extracting table from PDF: {e}")
        return None


def extract_metadata_from_pdf(pdf_content: bytes) -> Dict[str, Optional[str]]:
    """
    Extract employee name and pay period from PDF.
    Supports two PDF formats:
    1. Frappe HR PDF format (with "Employee" and "Pay Period" in summary table)
    2. Working Hours PDF format (with "WORK HOURS — Employee Name" in title and "Period" in summary table)
    
    Args:
        pdf_content: PDF file content as bytes
    
    Returns:
        Dict with 'employee' and 'pay_period' keys
    """
    metadata = {
        'employee': None,
        'pay_period': None,
    }
    
    try:
        pdf_file = BytesIO(pdf_content)
        
        with pdfplumber.open(pdf_file) as pdf:
            # Extract text from all pages to find title (title might be on any page)
            all_text = ""
            first_page = pdf.pages[0]
            first_page_text = first_page.extract_text() or ""
            all_text = first_page_text
            
            # Also try extracting from tables on first page (summary table)
            first_page_tables = first_page.extract_tables()
            
            # Try to extract employee name from title (for Working Hours format)
            # Pattern: "WORK HOURS — Employee Name (number)" or "WORK HOURS — Employee Name"
            # Try multiple patterns for title extraction
            title_match = None
            if all_text:
                # Pattern 1: "WORK HOURS — Employee Name (number)" with em dash
                title_match = re.search(r'WORK\s+HOURS\s*[—]\s*([^(]+?)(?:\s*\([^)]+\))?', all_text, re.IGNORECASE)
                if not title_match:
                    # Pattern 2: "WORK HOURS — Employee Name (number)" with en dash
                    title_match = re.search(r'WORK\s+HOURS\s*[–]\s*([^(]+?)(?:\s*\([^)]+\))?', all_text, re.IGNORECASE)
                if not title_match:
                    # Pattern 3: "WORK HOURS - Employee Name (number)" with regular dash
                    title_match = re.search(r'WORK\s+HOURS\s*[-]\s*([^(]+?)(?:\s*\([^)]+\))?', all_text, re.IGNORECASE)
                if not title_match:
                    # Pattern 4: "WORK HOURS — Employee Name" (without number) with em dash
                    title_match = re.search(r'WORK\s+HOURS\s*[—]\s*([^\n(]+)', all_text, re.IGNORECASE)
                if not title_match:
                    # Pattern 5: "WORK HOURS — Employee Name" (without number) with en dash
                    title_match = re.search(r'WORK\s+HOURS\s*[–]\s*([^\n(]+)', all_text, re.IGNORECASE)
                if not title_match:
                    # Pattern 6: "WORK HOURS - Employee Name" (without number) with regular dash
                    title_match = re.search(r'WORK\s+HOURS\s*[-]\s*([^\n(]+)', all_text, re.IGNORECASE)
                if not title_match:
                    # Pattern 7: More flexible - any dash-like character
                    title_match = re.search(r'WORK\s+HOURS\s*[—–\-]\s*([^\n(]+?)(?:\s*\([^)]+\))?', all_text, re.IGNORECASE)
                
                if title_match:
                    employee_name = title_match.group(1).strip()
                    # Remove any trailing parentheses content if captured
                    employee_name = re.sub(r'\s*\([^)]+\)\s*$', '', employee_name)
                    employee_name = ' '.join(employee_name.split())
                    if employee_name:
                        metadata['employee'] = employee_name
            
            # Use first_page_text for other extractions
            text = first_page_text
            
            # Try to extract from summary table first (more reliable)
            if first_page_tables:
                for table in first_page_tables:
                    if not table or len(table) < 2:
                        continue
                    
                    # Look for summary table with "Metric", "Value" columns (both formats)
                    header_row = table[0]
                    header_str = ' '.join([str(cell) if cell else '' for cell in header_row]).lower()
                    
                    if 'metric' in header_str and 'value' in header_str:
                        # Found summary table, extract employee and pay period from Value column
                        for row in table[1:]:
                            if len(row) < 2:
                                continue
                            
                            metric = str(row[0] if row[0] else '').strip().lower()
                            value = str(row[1] if len(row) > 1 and row[1] else '').strip()
                            
                            # Extract employee name (Format 1: "Employee" metric)
                            if 'employee' in metric and value and not metadata.get('employee'):
                                # Clean up employee name (remove explanatory text)
                                employee_name = re.sub(r'\s+Your name as recorded.*$', '', value, flags=re.IGNORECASE)
                                employee_name = re.sub(r'\s+as recorded.*$', '', employee_name, flags=re.IGNORECASE)
                                employee_name = re.sub(r'\s+in the system.*$', '', employee_name, flags=re.IGNORECASE)
                                employee_name = ' '.join(employee_name.split())
                                metadata['employee'] = employee_name
                            
                            # Extract pay period (Format 1: "Pay Period" metric, Format 2: "Period" metric)
                            if ('pay period' in metric or metric == 'period') and value and not metadata.get('pay_period'):
                                # Clean up pay period (remove explanatory text)
                                pay_period_raw = value
                                pay_period_raw = re.sub(r'\s+The date range.*$', '', pay_period_raw, flags=re.IGNORECASE)
                                pay_period_raw = re.sub(r'\s+this report covers.*$', '', pay_period_raw, flags=re.IGNORECASE)
                                pay_period_raw = re.sub(r'\s+The date.*$', '', pay_period_raw, flags=re.IGNORECASE)
                                # Extract just the date range part - try multiple patterns
                                date_range_match = re.search(r'(\d{4}[-/]\d{2}[-/]\d{2}\s*[–—-to]+\s*\d{4}[-/]\d{2}[-/]\d{2})', pay_period_raw)
                                if not date_range_match:
                                    # Try without spaces around dash
                                    date_range_match = re.search(r'(\d{4}[-/]\d{2}[-/]\d{2}[–—-]\d{4}[-/]\d{2}[-/]\d{2})', pay_period_raw)
                                if date_range_match:
                                    pay_period_raw = date_range_match.group(1).strip()
                                # Convert format
                                pay_period = convert_pay_period_format(pay_period_raw)
                                if pay_period and pay_period != pay_period_raw:  # Only set if conversion succeeded
                                    metadata['pay_period'] = pay_period
            
            # Fallback to text extraction if not found in tables
            if not metadata.get('employee') or not metadata.get('pay_period'):
                if text:
                    # Extract employee name (look for "Employee" label or try title again)
                    if not metadata.get('employee'):
                        # Try title extraction again with all patterns (in case it wasn't found earlier)
                        title_match = None
                        if text:
                            title_match = re.search(r'WORK\s+HOURS\s*[—]\s*([^(]+?)(?:\s*\([^)]+\))?', text, re.IGNORECASE)
                            if not title_match:
                                title_match = re.search(r'WORK\s+HOURS\s*[–]\s*([^(]+?)(?:\s*\([^)]+\))?', text, re.IGNORECASE)
                            if not title_match:
                                title_match = re.search(r'WORK\s+HOURS\s*[-]\s*([^(]+?)(?:\s*\([^)]+\))?', text, re.IGNORECASE)
                            if not title_match:
                                title_match = re.search(r'WORK\s+HOURS\s*[—–\-]\s*([^\n(]+)', text, re.IGNORECASE)
                        
                        if title_match:
                            employee_name = title_match.group(1).strip()
                            employee_name = re.sub(r'\s*\([^)]+\)\s*$', '', employee_name)
                            employee_name = ' '.join(employee_name.split())
                            if employee_name:
                                metadata['employee'] = employee_name
                        
                        # If still not found, try "Employee" label pattern
                        if not metadata.get('employee'):
                            employee_match = re.search(r'Employee[:\s]+([^\n]+?)(?:\s+Your name as recorded|$)', text, re.IGNORECASE)
                            if not employee_match:
                                # Fallback: try without the lookahead
                                employee_match = re.search(r'Employee[:\s]+([^\n]+)', text, re.IGNORECASE)
                            
                            if employee_match:
                                employee_name = employee_match.group(1).strip()
                                # Remove extra explanatory text that might have been captured
                                employee_name = re.sub(r'\s+Your name as recorded.*$', '', employee_name, flags=re.IGNORECASE)
                                employee_name = re.sub(r'\s+as recorded.*$', '', employee_name, flags=re.IGNORECASE)
                                employee_name = re.sub(r'\s+in the system.*$', '', employee_name, flags=re.IGNORECASE)
                                # Remove extra whitespace and clean up
                                employee_name = ' '.join(employee_name.split())
                                if employee_name:
                                    metadata['employee'] = employee_name
                    
                    # Extract pay period (look for "Pay Period" or "Period" label)
                    if not metadata.get('pay_period'):
                        # Pattern: "Pay Period" or "Period" followed by date range
                        pay_period_match = re.search(r'(?:Pay\s+)?Period[:\s]+([^\n]+?)(?:\s+The date range|$)', text, re.IGNORECASE)
                        if not pay_period_match:
                            # Fallback: try without the lookahead
                            pay_period_match = re.search(r'(?:Pay\s+)?Period[:\s]+([^\n]+)', text, re.IGNORECASE)
                        
                        if pay_period_match:
                            pay_period_raw = pay_period_match.group(1).strip()
                            # Remove extra explanatory text that might have been captured
                            pay_period_raw = re.sub(r'\s+The date range.*$', '', pay_period_raw, flags=re.IGNORECASE)
                            pay_period_raw = re.sub(r'\s+this report covers.*$', '', pay_period_raw, flags=re.IGNORECASE)
                            pay_period_raw = re.sub(r'\s+The date.*$', '', pay_period_raw, flags=re.IGNORECASE)
                            # Extract just the date range part (before any explanatory text)
                            # Look for date pattern: YYYY-MM-DD - YYYY-MM-DD or YYYY-MM-DD to YYYY-MM-DD
                            # Also handle em dash (—) and en dash (–)
                            date_range_match = re.search(r'(\d{4}[-/]\d{2}[-/]\d{2}\s*[–—-to]+\s*\d{4}[-/]\d{2}[-/]\d{2})', pay_period_raw)
                            if not date_range_match:
                                # Try without spaces around dash
                                date_range_match = re.search(r'(\d{4}[-/]\d{2}[-/]\d{2}[–—-]\d{4}[-/]\d{2}[-/]\d{2})', pay_period_raw)
                            if date_range_match:
                                pay_period_raw = date_range_match.group(1).strip()
                            # Convert format from "2025-01-01 - 2025-01-15" to "20250101-20250115"
                            pay_period = convert_pay_period_format(pay_period_raw)
                            if pay_period and pay_period != pay_period_raw:  # Only set if conversion succeeded
                                metadata['pay_period'] = pay_period
    except Exception as e:
        print(f"Error extracting metadata from PDF: {e}")
    
    return metadata


def convert_pay_period_format(pay_period_str: str) -> str:
    """
    Convert pay period from "2025-01-01 - 2025-01-15" to "20250101-20250115".
    
    Args:
        pay_period_str: Pay period string in various formats
    
    Returns:
        Pay period in ngTeco format (YYYYMMDD-YYYYMMDD), or original string if conversion fails
    """
    if not pay_period_str:
        return pay_period_str
    
    try:
        # Format 4: Already in ngTeco format "20250101-20250115"
        if re.match(r'^\d{8}-\d{8}$', pay_period_str.strip()):
            return pay_period_str.strip()
        
        # Try different formats
        # Format 1: "2025-01-01 - 2025-01-15" (space-dash-space)
        if ' - ' in pay_period_str:
            parts = pay_period_str.split(' - ', 1)
            if len(parts) == 2:
                start_date = datetime.strptime(parts[0].strip(), '%Y-%m-%d')
                end_date = datetime.strptime(parts[1].strip(), '%Y-%m-%d')
                return f"{start_date.strftime('%Y%m%d')}-{end_date.strftime('%Y%m%d')}"
        
        # Format 2: "2025-01-01 to 2025-01-15"
        if ' to ' in pay_period_str.lower():
            parts = re.split(r'\s+to\s+', pay_period_str, flags=re.IGNORECASE, maxsplit=1)
            if len(parts) == 2:
                start_date = datetime.strptime(parts[0].strip(), '%Y-%m-%d')
                end_date = datetime.strptime(parts[1].strip(), '%Y-%m-%d')
                return f"{start_date.strftime('%Y%m%d')}-{end_date.strftime('%Y%m%d')}"
        
        # Format 3: "2025-07-01 – 2025-10-05" (em dash or en dash with spaces)
        if '–' in pay_period_str or '—' in pay_period_str:
            # Replace em dash and en dash with regular dash for splitting
            normalized = pay_period_str.replace('–', ' - ').replace('—', ' - ')
            parts = normalized.split(' - ', 1)
            if len(parts) == 2:
                start_date = datetime.strptime(parts[0].strip(), '%Y-%m-%d')
                end_date = datetime.strptime(parts[1].strip(), '%Y-%m-%d')
                return f"{start_date.strftime('%Y%m%d')}-{end_date.strftime('%Y%m%d')}"
        
        # Format 5: "2025-07-01–2025-10-05" (em dash or en dash without spaces)
        if re.search(r'\d{4}-\d{2}-\d{2}[–—]\d{4}-\d{2}-\d{2}', pay_period_str):
            match = re.search(r'(\d{4}-\d{2}-\d{2})[–—](\d{4}-\d{2}-\d{2})', pay_period_str)
            if match:
                start_date = datetime.strptime(match.group(1), '%Y-%m-%d')
                end_date = datetime.strptime(match.group(2), '%Y-%m-%d')
                return f"{start_date.strftime('%Y%m%d')}-{end_date.strftime('%Y%m%d')}"
        
    except Exception as e:
        print(f"Error converting pay period format '{pay_period_str}': {e}")
    
    return pay_period_str


def parse_date_from_table(date_str: str) -> Optional[str]:
    """
    Parse date from table and convert to YYYYMMDD format.
    
    Args:
        date_str: Date string from PDF table (could be various formats)
    
    Returns:
        Date in YYYYMMDD format, or None if parsing fails
    """
    if not date_str or pd.isna(date_str):
        return None
    
    date_str = str(date_str).strip()
    
    # Try different date formats
    formats = [
        '%Y-%m-%d',      # 2025-01-15
        '%d-%m-%Y',      # 15-01-2025
        '%m/%d/%Y',      # 01/15/2025
        '%d/%m/%Y',      # 15/01/2025
        '%Y%m%d',        # 20250115 (already in correct format)
    ]
    
    for fmt in formats:
        try:
            date_obj = datetime.strptime(date_str, fmt)
            return date_obj.strftime('%Y%m%d')
        except:
            continue
    
    return None


def parse_time_from_table(time_str: str) -> Optional[str]:
    """
    Parse time from table and convert to HH:MM format.
    
    Args:
        time_str: Time string from PDF table
    
    Returns:
        Time in HH:MM format, or None if parsing fails
    """
    if not time_str or pd.isna(time_str):
        return None
    
    time_str = str(time_str).strip()
    
    # Remove any extra whitespace
    time_str = ' '.join(time_str.split())
    
    # Try different time formats
    formats = [
        '%H:%M',         # 09:00
        '%H:%M:%S',      # 09:00:00
        '%I:%M %p',      # 09:00 AM
        '%I:%M:%S %p',   # 09:00:00 AM
    ]
    
    for fmt in formats:
        try:
            time_obj = datetime.strptime(time_str, fmt)
            return time_obj.strftime('%H:%M')
        except:
            continue
    
    # Try to extract HH:MM pattern directly
    time_match = re.search(r'(\d{1,2}):(\d{2})', time_str)
    if time_match:
        hours = int(time_match.group(1))
        minutes = int(time_match.group(2))
        if 0 <= hours <= 23 and 0 <= minutes <= 59:
            return f"{hours:02d}:{minutes:02d}"
    
    return None


def get_day_abbreviation(date_obj: date) -> str:
    """
    Get day abbreviation (MON, TUE, etc.) from date.
    
    Args:
        date_obj: Date object
    
    Returns:
        Day abbreviation (MON, TUE, WED, THU, FRI, SAT, SUN)
    """
    days = ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
    return days[date_obj.weekday()]


def convert_pdf_to_ngteco_csv(pdf_content: bytes, employee_name: Optional[str] = None, pay_period: Optional[str] = None) -> Tuple[Optional[str], Optional[str]]:
    """
    Convert PDF report to ngTeco CSV format.
    
    Args:
        pdf_content: PDF file content as bytes
        employee_name: Optional employee name (if extraction fails, can be provided manually)
        pay_period: Optional pay period in format YYYYMMDD-YYYYMMDD (if extraction fails, can be provided manually)
    
    Returns:
        Tuple of (csv_content, error_message)
        csv_content: ngTeco CSV format string if successful, None otherwise
        error_message: Error message if conversion fails, None otherwise
    """
    try:
        # Extract metadata (only if not provided)
        if not employee_name or not pay_period:
            metadata = extract_metadata_from_pdf(pdf_content)
            if not employee_name:
                employee_name = metadata.get('employee')
            if not pay_period:
                pay_period = metadata.get('pay_period')
        
        if not employee_name:
            return None, "Could not extract employee name from PDF"
        
        if not pay_period:
            return None, "Could not extract pay period from PDF"
        
        # Extract table data
        df = extract_table_from_pdf(pdf_content)
        if df is None or df.empty:
            return None, "Could not extract table data from PDF"
        
        # Find Date, IN, OUT columns (handle variations in column names)
        date_col = None
        in_col = None
        out_col = None
        day_col = None
        
        for col in df.columns:
            col_lower = str(col).lower().strip()
            if 'date' in col_lower and date_col is None:
                date_col = col
            elif col_lower == 'in' or col_lower.startswith('in'):
                in_col = col
            elif col_lower == 'out' or col_lower.startswith('out'):
                out_col = col
            elif ('day' in col_lower or col_lower == 'dow') and day_col is None:
                # Handle both "Day" and "DOW" (Day of Week) columns
                day_col = col
        
        if date_col is None:
            return None, "Could not find Date column in PDF table"
        
        if in_col is None:
            return None, "Could not find IN column in PDF table"
        
        if out_col is None:
            return None, "Could not find OUT column in PDF table"
        
        # Parse pay period to get date range
        try:
            # Pay period format: YYYYMMDD-YYYYMMDD
            if '-' in pay_period:
                parts = pay_period.split('-')
                if len(parts) == 2:
                    start_date_str = parts[0].strip()
                    end_date_str = parts[1].strip()
                    start_date = datetime.strptime(start_date_str, '%Y%m%d').date()
                    end_date = datetime.strptime(end_date_str, '%Y%m%d').date()
                else:
                    return None, f"Invalid pay period format: {pay_period}"
            else:
                return None, f"Invalid pay period format: {pay_period}"
        except Exception as e:
            return None, f"Error parsing pay period '{pay_period}': {str(e)}"
        
        # Build a dictionary of dates from PDF table
        pdf_data_by_date = {}
        for _, row in df.iterrows():
            date_val = row.get(date_col)
            in_time_val = row.get(in_col)
            out_time_val = row.get(out_col)
            day_val = row.get(day_col) if day_col else None
            
            # Parse date
            date_str = parse_date_from_table(str(date_val) if date_val else '')
            if not date_str:
                continue
            
            try:
                date_obj = datetime.strptime(date_str, '%Y%m%d').date()
            except:
                continue
            
            # Parse times
            in_time = parse_time_from_table(str(in_time_val) if in_time_val else '')
            out_time = parse_time_from_table(str(out_time_val) if out_time_val else '')
            
            # Get day abbreviation
            if day_val:
                day_str = str(day_val).strip().upper()
                if len(day_str) > 3:
                    day_abbr = day_str[:3]
                else:
                    day_abbr = day_str
            else:
                day_abbr = get_day_abbreviation(date_obj)
            
            # Store in dictionary (even if IN/OUT are empty)
            pdf_data_by_date[date_obj] = {
                'day_abbr': day_abbr,
                'in_time': in_time or '',
                'out_time': out_time or ''
            }
        
        # Generate all dates in the pay period range
        all_dates = []
        current_date = start_date
        while current_date <= end_date:
            all_dates.append(current_date)
            # Move to next day
            current_date += timedelta(days=1)
        
        # Build ngTeco CSV format
        csv_lines = []
        
        # Header lines
        csv_lines.append(",,,,Timecard Report,,")
        csv_lines.append(f"Pay Period,,,{pay_period},,,")
        csv_lines.append(f"Employee,,,{employee_name},,,")
        csv_lines.append("Date,,IN,OUT,Work Time, Daily Total, Note")
        
        # Process all dates in the range
        for date_obj in sorted(all_dates):
            date_str = date_obj.strftime('%Y%m%d')
            day_abbr = get_day_abbreviation(date_obj)
            
            # Check if this date exists in PDF data
            if date_obj in pdf_data_by_date:
                # Use data from PDF
                pdf_data = pdf_data_by_date[date_obj]
                in_time = pdf_data['in_time']
                out_time = pdf_data['out_time']
                # Use day abbreviation from PDF if available, otherwise use calculated one
                if pdf_data.get('day_abbr'):
                    day_abbr = pdf_data['day_abbr']
            else:
                # Date not in PDF, use empty IN/OUT
                in_time = ''
                out_time = ''
            
            # Build CSV row (ngTeco format: Day,Date,IN,OUT,Work Time, Daily Total, Note)
            # Note: Work Time and Daily Total are left empty, Note is also empty
            csv_row = f"{day_abbr},{date_str},{in_time},{out_time},,"
            csv_lines.append(csv_row)
        
        # Add total hours line (empty for now, can be calculated if needed)
        csv_lines.append("Total Hours,,,,,,")
        
        csv_content = '\n'.join(csv_lines)
        return csv_content, None
        
    except Exception as e:
        return None, f"Error converting PDF to ngTeco CSV: {str(e)}"

