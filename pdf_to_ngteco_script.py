"""
PDF to ngTeco CSV Converter Script
Extracts IN/OUT times and dates from PDF reports and converts them to ngTeco CSV format.

This script:
1. Parses PDF files generated by the platform
2. Extracts table data (Date, IN, OUT, Day, etc.)
3. Converts to ngTeco CSV format
"""

import pandas as pd
from datetime import datetime, date
from typing import Dict, List, Optional, Tuple
import re
import pdfplumber
from io import BytesIO


def extract_table_from_pdf(pdf_content: bytes) -> Optional[pd.DataFrame]:
    """
    Extract the detailed work log table from PDF.
    Extracts from all pages and combines all matching tables.
    
    Args:
        pdf_content: PDF file content as bytes
    
    Returns:
        DataFrame with extracted table data from all pages, or None if extraction fails
    """
    try:
        pdf_file = BytesIO(pdf_content)
        all_data_rows = []
        header_row = None
        
        with pdfplumber.open(pdf_file) as pdf:
            for page_num, page in enumerate(pdf.pages):
                # Extract tables from each page
                page_tables = page.extract_tables()
                
                if not page_tables:
                    continue
                
                for table in page_tables:
                    if not table or len(table) < 2:
                        continue
                    
                    # Check if this table has the expected columns
                    current_header = table[0]
                    header_str = ' '.join([str(cell) if cell else '' for cell in current_header]).lower()
                    
                    if 'date' in header_str and 'in' in header_str and 'out' in header_str:
                        # Found a detailed work log table
                        # Store header if not already stored
                        if header_row is None:
                            header_row = current_header
                        
                        # Add data rows (skip header row)
                        for row in table[1:]:
                            # Skip if this looks like a header row (contains "Date", "IN", "OUT" as text)
                            row_str = ' '.join([str(cell) if cell else '' for cell in row]).lower()
                            if 'date' in row_str and ('in' in row_str or 'out' in row_str):
                                continue  # Skip header rows that appear in the middle
                            
                            # Only add rows that have at least some data
                            if row and any(cell and str(cell).strip() for cell in row):
                                all_data_rows.append(row)
        
        # If we found data, create DataFrame
        if header_row and all_data_rows:
            # Clean header row
            cleaned_header = [str(col).strip().replace('\n', ' ') if col else '' for col in header_row]
            
            # Create DataFrame
            df = pd.DataFrame(all_data_rows, columns=cleaned_header)
            
            # Clean up the DataFrame
            df = df.dropna(how='all')  # Remove completely empty rows
            
            # Find Date column for duplicate detection
            date_col = None
            for col in df.columns:
                if 'date' in str(col).lower():
                    date_col = col
                    break
            
            # Remove duplicate rows based on Date (if available), otherwise use all columns
            if date_col:
                # Remove duplicates based on Date column
                df = df.drop_duplicates(subset=[date_col], keep='first')
            else:
                # Fallback: remove duplicates based on all columns
                df = df.drop_duplicates()
            
            return df
        
        return None
    except Exception as e:
        print(f"Error extracting table from PDF: {e}")
        return None


def extract_metadata_from_pdf(pdf_content: bytes) -> Dict[str, Optional[str]]:
    """
    Extract employee name and pay period from PDF.
    
    Args:
        pdf_content: PDF file content as bytes
    
    Returns:
        Dict with 'employee' and 'pay_period' keys
    """
    metadata = {
        'employee': None,
        'pay_period': None,
    }
    
    try:
        pdf_file = BytesIO(pdf_content)
        
        with pdfplumber.open(pdf_file) as pdf:
            # Extract text from first page (usually has summary/metadata)
            first_page = pdf.pages[0]
            text = first_page.extract_text()
            
            # Also try extracting from tables on first page (summary table)
            first_page_tables = first_page.extract_tables()
            
            # Try to extract from summary table first (more reliable)
            if first_page_tables:
                for table in first_page_tables:
                    if not table or len(table) < 2:
                        continue
                    
                    # Look for summary table with "Metric", "Value", "What This Means" columns
                    header_row = table[0]
                    header_str = ' '.join([str(cell) if cell else '' for cell in header_row]).lower()
                    
                    if 'metric' in header_str and 'value' in header_str:
                        # Found summary table, extract employee and pay period from Value column
                        for row in table[1:]:
                            if len(row) < 2:
                                continue
                            
                            metric = str(row[0] if row[0] else '').strip().lower()
                            value = str(row[1] if len(row) > 1 and row[1] else '').strip()
                            
                            if 'employee' in metric and value and not metadata.get('employee'):
                                # Clean up employee name (remove explanatory text)
                                employee_name = re.sub(r'\s+Your name as recorded.*$', '', value, flags=re.IGNORECASE)
                                employee_name = re.sub(r'\s+as recorded.*$', '', employee_name, flags=re.IGNORECASE)
                                employee_name = re.sub(r'\s+in the system.*$', '', employee_name, flags=re.IGNORECASE)
                                employee_name = ' '.join(employee_name.split())
                                metadata['employee'] = employee_name
                            
                            if 'pay period' in metric and value and not metadata.get('pay_period'):
                                # Clean up pay period (remove explanatory text)
                                pay_period = re.sub(r'\s+The date range.*$', '', value, flags=re.IGNORECASE)
                                pay_period = re.sub(r'\s+this report covers.*$', '', pay_period, flags=re.IGNORECASE)
                                pay_period = re.sub(r'\s+The date.*$', '', pay_period, flags=re.IGNORECASE)
                                # Extract just the date range part
                                date_range_match = re.search(r'(\d{4}[-/]\d{2}[-/]\d{2}\s*[-to]+\s*\d{4}[-/]\d{2}[-/]\d{2})', pay_period)
                                if date_range_match:
                                    pay_period = date_range_match.group(1).strip()
                                # Convert format
                                pay_period = convert_pay_period_format(pay_period)
                                metadata['pay_period'] = pay_period
            
            # Fallback to text extraction if not found in tables
            if not metadata.get('employee') or not metadata.get('pay_period'):
                if text:
                    # Extract employee name (look for "Employee" label)
                    # Pattern: "Employee" followed by name, stop before explanatory text
                    employee_match = re.search(r'Employee[:\s]+([^\n]+?)(?:\s+Your name as recorded|$)', text, re.IGNORECASE)
                    if not employee_match:
                        # Fallback: try without the lookahead
                        employee_match = re.search(r'Employee[:\s]+([^\n]+)', text, re.IGNORECASE)
                    
                    if employee_match and not metadata.get('employee'):
                        employee_name = employee_match.group(1).strip()
                        # Remove extra explanatory text that might have been captured
                        employee_name = re.sub(r'\s+Your name as recorded.*$', '', employee_name, flags=re.IGNORECASE)
                        employee_name = re.sub(r'\s+as recorded.*$', '', employee_name, flags=re.IGNORECASE)
                        employee_name = re.sub(r'\s+in the system.*$', '', employee_name, flags=re.IGNORECASE)
                        # Remove extra whitespace and clean up
                        employee_name = ' '.join(employee_name.split())
                        metadata['employee'] = employee_name
                    
                    # Extract pay period (look for "Pay Period" label)
                    # Pattern: "Pay Period" followed by date range, stop before explanatory text
                    pay_period_match = re.search(r'Pay Period[:\s]+([^\n]+?)(?:\s+The date range|$)', text, re.IGNORECASE)
                    if not pay_period_match:
                        # Fallback: try without the lookahead
                        pay_period_match = re.search(r'Pay Period[:\s]+([^\n]+)', text, re.IGNORECASE)
                    
                    if pay_period_match and not metadata.get('pay_period'):
                        pay_period = pay_period_match.group(1).strip()
                        # Remove extra explanatory text that might have been captured
                        pay_period = re.sub(r'\s+The date range.*$', '', pay_period, flags=re.IGNORECASE)
                        pay_period = re.sub(r'\s+this report covers.*$', '', pay_period, flags=re.IGNORECASE)
                        pay_period = re.sub(r'\s+The date.*$', '', pay_period, flags=re.IGNORECASE)
                        # Extract just the date range part (before any explanatory text)
                        # Look for date pattern: YYYY-MM-DD - YYYY-MM-DD or YYYY-MM-DD to YYYY-MM-DD
                        date_range_match = re.search(r'(\d{4}[-/]\d{2}[-/]\d{2}\s*[-to]+\s*\d{4}[-/]\d{2}[-/]\d{2})', pay_period)
                        if date_range_match:
                            pay_period = date_range_match.group(1).strip()
                        # Convert format from "2025-01-01 - 2025-01-15" to "20250101-20250115"
                        pay_period = convert_pay_period_format(pay_period)
                        metadata['pay_period'] = pay_period
    except Exception as e:
        print(f"Error extracting metadata from PDF: {e}")
    
    return metadata


def convert_pay_period_format(pay_period_str: str) -> str:
    """
    Convert pay period from "2025-01-01 - 2025-01-15" to "20250101-20250115".
    
    Args:
        pay_period_str: Pay period string in various formats
    
    Returns:
        Pay period in ngTeco format (YYYYMMDD-YYYYMMDD)
    """
    try:
        # Try different formats
        # Format 1: "2025-01-01 - 2025-01-15"
        if ' - ' in pay_period_str:
            parts = pay_period_str.split(' - ')
            if len(parts) == 2:
                start_date = datetime.strptime(parts[0].strip(), '%Y-%m-%d')
                end_date = datetime.strptime(parts[1].strip(), '%Y-%m-%d')
                return f"{start_date.strftime('%Y%m%d')}-{end_date.strftime('%Y%m%d')}"
        
        # Format 2: "2025-01-01 to 2025-01-15"
        if ' to ' in pay_period_str:
            parts = pay_period_str.split(' to ')
            if len(parts) == 2:
                start_date = datetime.strptime(parts[0].strip(), '%Y-%m-%d')
                end_date = datetime.strptime(parts[1].strip(), '%Y-%m-%d')
                return f"{start_date.strftime('%Y%m%d')}-{end_date.strftime('%Y%m%d')}"
        
        # Format 3: Already in ngTeco format "20250101-20250115"
        if re.match(r'\d{8}-\d{8}', pay_period_str):
            return pay_period_str
        
    except Exception as e:
        print(f"Error converting pay period format: {e}")
    
    return pay_period_str


def parse_date_from_table(date_str: str) -> Optional[str]:
    """
    Parse date from table and convert to YYYYMMDD format.
    
    Args:
        date_str: Date string from PDF table (could be various formats)
    
    Returns:
        Date in YYYYMMDD format, or None if parsing fails
    """
    if not date_str or pd.isna(date_str):
        return None
    
    date_str = str(date_str).strip()
    
    # Try different date formats
    formats = [
        '%Y-%m-%d',      # 2025-01-15
        '%d-%m-%Y',      # 15-01-2025
        '%m/%d/%Y',      # 01/15/2025
        '%d/%m/%Y',      # 15/01/2025
        '%Y%m%d',        # 20250115 (already in correct format)
    ]
    
    for fmt in formats:
        try:
            date_obj = datetime.strptime(date_str, fmt)
            return date_obj.strftime('%Y%m%d')
        except:
            continue
    
    return None


def parse_time_from_table(time_str: str) -> Optional[str]:
    """
    Parse time from table and convert to HH:MM format.
    
    Args:
        time_str: Time string from PDF table
    
    Returns:
        Time in HH:MM format, or None if parsing fails
    """
    if not time_str or pd.isna(time_str):
        return None
    
    time_str = str(time_str).strip()
    
    # Remove any extra whitespace
    time_str = ' '.join(time_str.split())
    
    # Try different time formats
    formats = [
        '%H:%M',         # 09:00
        '%H:%M:%S',      # 09:00:00
        '%I:%M %p',      # 09:00 AM
        '%I:%M:%S %p',   # 09:00:00 AM
    ]
    
    for fmt in formats:
        try:
            time_obj = datetime.strptime(time_str, fmt)
            return time_obj.strftime('%H:%M')
        except:
            continue
    
    # Try to extract HH:MM pattern directly
    time_match = re.search(r'(\d{1,2}):(\d{2})', time_str)
    if time_match:
        hours = int(time_match.group(1))
        minutes = int(time_match.group(2))
        if 0 <= hours <= 23 and 0 <= minutes <= 59:
            return f"{hours:02d}:{minutes:02d}"
    
    return None


def get_day_abbreviation(date_obj: date) -> str:
    """
    Get day abbreviation (MON, TUE, etc.) from date.
    
    Args:
        date_obj: Date object
    
    Returns:
        Day abbreviation (MON, TUE, WED, THU, FRI, SAT, SUN)
    """
    days = ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
    return days[date_obj.weekday()]


def convert_pdf_to_ngteco_csv(pdf_content: bytes) -> Tuple[Optional[str], Optional[str]]:
    """
    Convert PDF report to ngTeco CSV format.
    
    Args:
        pdf_content: PDF file content as bytes
    
    Returns:
        Tuple of (csv_content, error_message)
        csv_content: ngTeco CSV format string if successful, None otherwise
        error_message: Error message if conversion fails, None otherwise
    """
    try:
        # Extract metadata
        metadata = extract_metadata_from_pdf(pdf_content)
        employee_name = metadata.get('employee')
        pay_period = metadata.get('pay_period')
        
        if not employee_name:
            return None, "Could not extract employee name from PDF"
        
        if not pay_period:
            return None, "Could not extract pay period from PDF"
        
        # Extract table data
        df = extract_table_from_pdf(pdf_content)
        if df is None or df.empty:
            return None, "Could not extract table data from PDF"
        
        # Find Date, IN, OUT columns (handle variations in column names)
        date_col = None
        in_col = None
        out_col = None
        day_col = None
        
        for col in df.columns:
            col_lower = str(col).lower().strip()
            if 'date' in col_lower and date_col is None:
                date_col = col
            elif col_lower == 'in' or col_lower.startswith('in'):
                in_col = col
            elif col_lower == 'out' or col_lower.startswith('out'):
                out_col = col
            elif 'day' in col_lower and day_col is None:
                day_col = col
        
        if date_col is None:
            return None, "Could not find Date column in PDF table"
        
        if in_col is None:
            return None, "Could not find IN column in PDF table"
        
        if out_col is None:
            return None, "Could not find OUT column in PDF table"
        
        # Build ngTeco CSV format
        csv_lines = []
        
        # Header lines
        csv_lines.append(",,,,Timecard Report,,")
        csv_lines.append(f"Pay Period,,,{pay_period},,,")
        csv_lines.append(f"Employee,,,{employee_name},,,")
        csv_lines.append("Date,,IN,OUT,Work Time, Daily Total, Note")
        
        # Process each row
        for _, row in df.iterrows():
            date_val = row.get(date_col)
            in_time_val = row.get(in_col)
            out_time_val = row.get(out_col)
            day_val = row.get(day_col) if day_col else None
            
            # Parse date
            date_str = parse_date_from_table(str(date_val) if date_val else '')
            if not date_str:
                continue
            
            # Parse times
            in_time = parse_time_from_table(str(in_time_val) if in_time_val else '')
            out_time = parse_time_from_table(str(out_time_val) if out_time_val else '')
            
            # Get day abbreviation
            if day_val:
                day_abbr = str(day_val).strip().upper()[:3]
            else:
                # Try to get day from date
                try:
                    date_obj = datetime.strptime(date_str, '%Y%m%d').date()
                    day_abbr = get_day_abbreviation(date_obj)
                except:
                    day_abbr = ''
            
            # Skip rows with no IN and OUT times
            if not in_time and not out_time:
                continue
            
            # Build CSV row (ngTeco format: Day,Date,IN,OUT,Work Time, Daily Total, Note)
            # Note: Work Time and Daily Total are left empty, Note is also empty
            csv_row = f"{day_abbr},{date_str},{in_time or ''},{out_time or ''},,"
            csv_lines.append(csv_row)
        
        # Add total hours line (empty for now, can be calculated if needed)
        csv_lines.append("Total Hours,,,,,,")
        
        csv_content = '\n'.join(csv_lines)
        return csv_content, None
        
    except Exception as e:
        return None, f"Error converting PDF to ngTeco CSV: {str(e)}"

